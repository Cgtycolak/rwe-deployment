const HTMLSearchableSelect = (function () {
    /* Private variables not accessed */
    /* small lib for create Multiple select input displayed nice and with search and native html input so easy to use the orginal select input and add any events to it and direct access it value so this html class only not related to any handle or even needed after just use your original html select (who can use this lib any html developer only) no need js exp to control the HTML Mutiple With Search element*/
    let hssIndex = 0;
    /* end private variables */

    class HTMLSearchableSelect {
        constructor(selectSelector) {
            /* required Args */
            const select = $(selectSelector);
            // validateRequiredArgs or throw error stop creation
            if (!select.length) {
                console.error(`HMWS Error select element with selector ${selectSelector} not found`);
                this.ready = false;
                this.shown = false;

            } else {
                this.index = ++hssIndex;
                this._select = selectSelector;
                this.select = select;
                this.debounceTimer = null;
                this.debounceDelay = 100;

                this.id = `hss_${this.index}`;

                this.searchId = `${this.id}_search`;
                this.searchSelector = `#${this.searchId}`;

                this.mainContId = `${this.id}_mcont`;
                this.mainContSelector = `#${this.mainContId}`;

                this.selectContid = `${this.id}_scont`;
                this.selectContSelector = `#${this.selectContid}`;

                this.totalSelectedId = `${this.id}_total`;
                this.totalSelectedSelector = `#${this.totalSelectedId}`;

                this.miniId = `${this.id}_mini`;
                this.miniSelector = `#${this.miniId}`;

                this.minContId = `${this.id}_mincont`;
                this.minContSelector = `#${this.minContId}`;

                this.minimizedHSSContId = `${this.id}_mhsscont`;
                this.minimizedHSSContSelector = `#${this.minimizedHSSContId}`;

                this.minimizedHSSId = `${this.id}_mhsswraper`;
                this.minimizedHSSSelector = `#${this.minimizedHSSId}`;


                this.selectAllId = `${this.id}_selectall`;
                this.selectAllSelector = `#${this.selectAllId}`;



                this.hiddenClass = `${this.id}_hidden`;
                this.hiddenSelector = `.${this.hiddenClass}`;


                /* optional label */
                this.name = select.attr('data-name') ? select.attr('data-name') : '';

                this.label = select.attr('data-label');
                /* optional placeholder */
                this._searchPlaceholder = select.attr('data-search-placeholder');
                this._searchStyle = select.attr('data-search-style');
                this._contStyle = select.attr('data-cont-style');
                this._labelStyle = select.attr('data-label-style');
                this._counterStyle = select.attr('data-counter-style');
                this._counter = select.attr('data-counter');
                this._minimizable = select.attr('data-minimizable');
                this._selectCheckbox = select.attr('data-select-checkbox');
                this._selectCheckboxStyle = select.attr('data-select-checkbox-style');
                this.selectChecked = false;

                /* performance improve for input (custom input event listener) */
                this.customInput = null;
                this.customInputWait = 100;
                this.customInputVal = null;

                this.setOptions();

                // display the HTMLMultipleWithSearch element
                /* ready for display */
                this.ready = true;
                this.displayAsHMWS();

                /* all global setups required and events run 1 time when init the HSS class */
                this.addGlobals();

            }
        }

        addGlobals() {
            /* configure new jquery selector for hss with hss domain (case insenstive select) (custom contains) */
            jQuery.expr[':'].hsscontains = function (elm, _i, m) {
                return $(elm).text().toLowerCase().indexOf(m[3].toLowerCase()) > -1;
            }
        }

        arraySlicer(bigArr, packageLength) {
            if (!packageLength || packageLength < 1) { return []; }
            let result = [];
            for (let i = 0; i < bigArr.length; i += packageLength) {
                result.push(bigArr.slice(i, ((i + packageLength))));
            }
            return result;
        }

        getOptionalVal(thisVar, defaultVal, templateCB = (val) => {
            return val;
        }) {
            /* optional placeholder for search input */
            if (thisVar) {
                /* attr exist with value */
                return templateCB(thisVar);

            } else if (typeof (thisVar) !== 'undefined') {
                /* attr defined but with null or empty val default */
                return templateCB(defaultVal);

            } else {
                /* attr not exist */
                return '';
            }
        }
        setOptions() {
            /* apply html provided options and select between display val or display default or omit default all controlled by html only (attr with val) (attr empty or exist) (attr not defined)
             */

            this.searchStyle = this.getOptionalVal(this._searchStyle, `font-size:0.750rem;`);
            this.labelStyle = this.getOptionalVal(this._labelStyle, ``);


            const placeHolderStr = (this.name) ? ` ${this.name}` : this.name;
            this.searchPlaceholder = this.getOptionalVal(this._searchPlaceholder, `Search${placeHolderStr}:`);

            this.contStyle = this.getOptionalVal(this._contStyle, `background:lavender !important;`);

            this.counterStyle = this.getOptionalVal(this._counterStyle, '');


            this.selectCheckboxStyle = this.getOptionalVal(this._selectCheckboxStyle, `background:gainsboro !important;`);

            /* 2options only attrs lower level programing */
            if (this._counter || typeof (this._counter) !== 'undefined') {
                this.counter = `<span class="badge" style="color: #fff; background-color: #6c757d;position:absolute;z-Index:100;right:0;top:0;${this.counterStyle}" title="Total Selected" id="${this.totalSelectedId}">0</span>`;
            } else {
                this.counter = '';
            }

            if (this._minimizable || typeof (this._minimizable) !== 'undefined') {
                this.minimizeBtn = `<i class="btn btn-sm btn-outline-light" style="font-size:0.725rem;padding:4px;" title="display minimized select" id="${this.miniId}">&#128229;</i>`;
                this.minimizedHSS = `<div style="display:none;" id="${this.minimizedHSSContId}" class="p-0 m-0 w-100">
              <button class="d-flex wrapper justify-content-between align-items-stretch w-100 btn btn-light text-white min_cont" type="button" id="${this.minContId}" title="display maximized select">
                 <div class="min_content d-flex justify-content-between align-items-center flex-wrap py-2" id="${this.minimizedHSSId}" style="max-height:200px;overflow:auto;"></div>
                 <div class="btn btn-sm btn-outline-light" style="font-size:0.725rem;padding:4px;" >&#128228;</div>
              </button>
           </div>`;
                this.minimizeMr = 'mr-1';

            } else {
                this.minimizeBtn = '';
                this.minimizedHSS = '';
                this.minimizeMr = '';
            }

            /* checkbox to Select/unselect all select items (optional controll to edit select element) */
            if (this._selectCheckbox || typeof (this._selectCheckbox) !== 'undefined') {
                this.selectCheckbox = `<div class="m-0 p-1 d-flex justify-content-center align-items-center" style="${this.selectCheckboxStyle}">
                    <input type="checkbox" class="select_all" id="${this.selectAllId}" title="toggle between 'check all options' and 'uncheck all options.' " />
                    </div>`;
            } else {
                this.selectCheckbox = '';
            }

            /* optional create html label if user set data-label with value */
            let labelStr = this.label || this.name;
            labelStr = (labelStr) ? ` ${labelStr}` : '';
            this.labelHTML = this.getOptionalVal(this.label, `Select${labelStr}:`, (val) => {
                return `<div class="col-sm-12 m-0 p-0" style="position:relative;">
                <label style="${this.labelStyle}">${val}</label>${this.counter}</div>`
            });

        }
        addEvents() {
            /* search input */
            if ($(this.searchSelector).length) {
                $(this.searchSelector).on('input.hss', () => {
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = setTimeout(() => {
                        this.search();
                    }, this.debounceDelay);
                });
            }
            if ($(this.miniSelector).length) {
                $(this.miniSelector).on('click.hss', () => {
                    this.minimize();
                });
            }
            if ($(this.minContSelector).length) {
                $(this.minContSelector).on('click.hss', () => {
                    this.maximize();
                });
            }

            /* toggle between select all checkboxes and unselect all */
            if ($(this.selectAllSelector).length) {
                $(this.selectAllSelector).on('change.hss', () => {
                    this.toggleSelect();
                });
            }


            /* select change (select element in state change not removed like the search input (show or hide select not removed so here off prev event) */
            if (this.select.length) {
                this.select.off('change.hss');
                this.select.on('change.hss', () => {
                    this.updateVal()
                });
            }

        }
        displayAsHMWS() {
            if (this.ready) {
                this.hss = $(`
            <div class="hss-select row m-1 p-1 border rounded" style="${this.contStyle}" id="${this.mainContId}">
                ${this.labelHTML} <!-- optional label -->
                ${this.minimizedHSS} <!-- optional minimizedHSS -->
                <div class="col-sm-12 row m-0 p-0 minimize_target">
                    <div class="col-sm-12 m-0 p-0 d-flex">
                        ${this.selectCheckbox}
                        <input type="text" class="form-control ${this.minimizeMr}" id="${this.searchId}" placeholder="${this.searchPlaceholder}" style="${this.searchStyle}" />
                        <!-- optional minimizeBtn -->
                        ${this.minimizeBtn}
                    </div>
                    <div class="col-sm-12 m-0 p-0" id="${this.selectContid}"></div>
                </div>
            </div>`);
                this.select.parent()[0].insertBefore(this.hss[0], this.select[0]);
                $(this.selectContSelector)[0].appendChild(this.select[0]);
                this.shown = true;

                // add events or readd
                this.addEvents();

            }
            return this;
        }
        cancelDisplay() {
            if (this.ready) {
                if (this.shown) {
                    /* back the select as normal select html element */
                    $(this.mainContSelector).parent()[0].insertBefore(this.select[0], $(this.mainContSelector)[0]);
                    $(this.mainContSelector).remove();
                    this.shown = false;
                }
            }
            return this;
        }
        minimize() {
            this.hss.find('.minimize_target').hide();
            $(this.minimizedHSSContSelector).show();
        }
        maximize() {
            $(this.minimizedHSSContSelector).hide();
            this.hss.find('.minimize_target').show();
        }
        toggleSelect() {

            if (this.selectChecked) {
                this.select.find('option:visible:selected').prop('selected', false).end().trigger('change');
                this.selectChecked = false;
            } else {
                this.select.find('option:visible').prop('selected', true).end().trigger('change');
                this.selectChecked = true;
            }
        }
        search() {

            const searchVal = $(this.searchSelector).val().toLowerCase();
            const options = this.select.find('option');

            options.hide();
            if (searchVal) {
                options.filter((_i, e) => (e.innerText.toLowerCase().indexOf(searchVal) > -1)).show();
            } else {
                options.show();
            }
        }
        updateVal() {
            if (this.select.length && typeof (this.select.val()) !== 'undefined') {
                this.val = this.select.val();
                $(this.totalSelectedSelector).html(this.val.length);

                /* update mini select data */
                if ($(this.minimizedHSSSelector).length) {
                    let miniHTML = '';
                    this.select.find('option:selected').each((_i, opt) => {
                        miniHTML += `<div title="${$(opt).val()}: ${$(opt).text()}" class="badge btn-outline-secondary border border-dark d-flex justify-content-center align-items-center mr-1" style="max-width:15vw !important;overflow:hidden">${$(opt).text()}</div>`;
                    });
                    $(this.minimizedHSSSelector).html(miniHTML);
                }
                // console.log('updateVal', this);
            }


        }
    }
    return HTMLSearchableSelect;
})();